//----------------------
// <auto-generated>
//     Generated using the NSwag toolchain v13.18.2.0 (NJsonSchema v10.8.0.0 (Newtonsoft.Json v13.0.0.0)) (http://NSwag.org)
// </auto-generated>
//----------------------

/* tslint:disable */
/* eslint-disable */
// ReSharper disable InconsistentNaming

import { mergeMap as _observableMergeMap, catchError as _observableCatch } from 'rxjs/operators';
import { Observable, throwError as _observableThrow, of as _observableOf } from 'rxjs';
import { Injectable, Inject, Optional, InjectionToken } from '@angular/core';
import { HttpClient, HttpHeaders, HttpResponse, HttpResponseBase } from '@angular/common/http';

export const API_BASE_URL = new InjectionToken<string>('API_BASE_URL');

export interface ICoursesClient {
    get(name: string | null | undefined, pageNumber: number | undefined, pageSize: number | undefined): Observable<PaginatedListOfCourseDto>;
    create(command: CreateCourseCommand): Observable<number>;
    getAll(): Observable<CourseDto[]>;
    getAll2(getCoursesQuery: GetAcademicStaffCoursesQuery | null | undefined): Observable<CourseDto[]>;
    getCourse(id: number): Observable<CourseDto>;
    update(id: number, command: UpdateCourseCommand): Observable<CourseDto>;
    delete(id: number): Observable<number>;
}

@Injectable({
    providedIn: 'root'
})
export class CoursesClient implements ICoursesClient {
    private http: HttpClient;
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(@Inject(HttpClient) http: HttpClient, @Optional() @Inject(API_BASE_URL) baseUrl?: string) {
        this.http = http;
        this.baseUrl = baseUrl !== undefined && baseUrl !== null ? baseUrl : "";
    }

    get(name: string | null | undefined, pageNumber: number | undefined, pageSize: number | undefined): Observable<PaginatedListOfCourseDto> {
        let url_ = this.baseUrl + "/api/Courses?";
        if (name !== undefined && name !== null)
            url_ += "Name=" + encodeURIComponent("" + name) + "&";
        if (pageNumber === null)
            throw new Error("The parameter 'pageNumber' cannot be null.");
        else if (pageNumber !== undefined)
            url_ += "PageNumber=" + encodeURIComponent("" + pageNumber) + "&";
        if (pageSize === null)
            throw new Error("The parameter 'pageSize' cannot be null.");
        else if (pageSize !== undefined)
            url_ += "PageSize=" + encodeURIComponent("" + pageSize) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGet(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGet(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<PaginatedListOfCourseDto>;
                }
            } else
                return _observableThrow(response_) as any as Observable<PaginatedListOfCourseDto>;
        }));
    }

    protected processGet(response: HttpResponseBase): Observable<PaginatedListOfCourseDto> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = PaginatedListOfCourseDto.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    create(command: CreateCourseCommand): Observable<number> {
        let url_ = this.baseUrl + "/api/Courses";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(command);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json",
                "Accept": "application/json"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processCreate(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processCreate(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<number>;
                }
            } else
                return _observableThrow(response_) as any as Observable<number>;
        }));
    }

    protected processCreate(response: HttpResponseBase): Observable<number> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
                result200 = resultData200 !== undefined ? resultData200 : <any>null;
    
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    getAll(): Observable<CourseDto[]> {
        let url_ = this.baseUrl + "/api/Courses/list";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetAll(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetAll(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<CourseDto[]>;
                }
            } else
                return _observableThrow(response_) as any as Observable<CourseDto[]>;
        }));
    }

    protected processGetAll(response: HttpResponseBase): Observable<CourseDto[]> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (Array.isArray(resultData200)) {
                result200 = [] as any;
                for (let item of resultData200)
                    result200!.push(CourseDto.fromJS(item));
            }
            else {
                result200 = <any>null;
            }
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    getAll2(getCoursesQuery: GetAcademicStaffCoursesQuery | null | undefined): Observable<CourseDto[]> {
        let url_ = this.baseUrl + "/api/Courses/academic?";
        if (getCoursesQuery !== undefined && getCoursesQuery !== null)
            url_ += "getCoursesQuery=" + encodeURIComponent("" + getCoursesQuery) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetAll2(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetAll2(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<CourseDto[]>;
                }
            } else
                return _observableThrow(response_) as any as Observable<CourseDto[]>;
        }));
    }

    protected processGetAll2(response: HttpResponseBase): Observable<CourseDto[]> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (Array.isArray(resultData200)) {
                result200 = [] as any;
                for (let item of resultData200)
                    result200!.push(CourseDto.fromJS(item));
            }
            else {
                result200 = <any>null;
            }
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    getCourse(id: number): Observable<CourseDto> {
        let url_ = this.baseUrl + "/api/Courses/{id}";
        if (id === undefined || id === null)
            throw new Error("The parameter 'id' must be defined.");
        url_ = url_.replace("{id}", encodeURIComponent("" + id));
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetCourse(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetCourse(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<CourseDto>;
                }
            } else
                return _observableThrow(response_) as any as Observable<CourseDto>;
        }));
    }

    protected processGetCourse(response: HttpResponseBase): Observable<CourseDto> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = CourseDto.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    update(id: number, command: UpdateCourseCommand): Observable<CourseDto> {
        let url_ = this.baseUrl + "/api/Courses/{id}";
        if (id === undefined || id === null)
            throw new Error("The parameter 'id' must be defined.");
        url_ = url_.replace("{id}", encodeURIComponent("" + id));
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(command);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json",
                "Accept": "application/json"
            })
        };

        return this.http.request("put", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processUpdate(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processUpdate(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<CourseDto>;
                }
            } else
                return _observableThrow(response_) as any as Observable<CourseDto>;
        }));
    }

    protected processUpdate(response: HttpResponseBase): Observable<CourseDto> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = CourseDto.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    delete(id: number): Observable<number> {
        let url_ = this.baseUrl + "/api/Courses/{id}";
        if (id === undefined || id === null)
            throw new Error("The parameter 'id' must be defined.");
        url_ = url_.replace("{id}", encodeURIComponent("" + id));
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("delete", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processDelete(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processDelete(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<number>;
                }
            } else
                return _observableThrow(response_) as any as Observable<number>;
        }));
    }

    protected processDelete(response: HttpResponseBase): Observable<number> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
                result200 = resultData200 !== undefined ? resultData200 : <any>null;
    
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }
}

export interface IExamsClient {
    getExam(name: string | null): Observable<ExamDto>;
    getExams(name: string | null | undefined, pageNumber: number | undefined, pageSize: number | undefined): Observable<PaginatedListOfExamDto>;
    createExam(createExamCommand: CreateExamCommand): Observable<number>;
    getExamsAll(): Observable<ExamDto[]>;
    getExam2(id: number): Observable<ExamDto>;
    update(id: number, command: UpdateExamCommand): Observable<ExamDto>;
    delete(id: number): Observable<number>;
}

@Injectable({
    providedIn: 'root'
})
export class ExamsClient implements IExamsClient {
    private http: HttpClient;
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(@Inject(HttpClient) http: HttpClient, @Optional() @Inject(API_BASE_URL) baseUrl?: string) {
        this.http = http;
        this.baseUrl = baseUrl !== undefined && baseUrl !== null ? baseUrl : "";
    }

    getExam(name: string | null): Observable<ExamDto> {
        let url_ = this.baseUrl + "/api/Exams/{name}";
        if (name === undefined || name === null)
            throw new Error("The parameter 'name' must be defined.");
        url_ = url_.replace("{name}", encodeURIComponent("" + name));
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetExam(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetExam(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<ExamDto>;
                }
            } else
                return _observableThrow(response_) as any as Observable<ExamDto>;
        }));
    }

    protected processGetExam(response: HttpResponseBase): Observable<ExamDto> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = ExamDto.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    getExams(name: string | null | undefined, pageNumber: number | undefined, pageSize: number | undefined): Observable<PaginatedListOfExamDto> {
        let url_ = this.baseUrl + "/api/Exams?";
        if (name !== undefined && name !== null)
            url_ += "Name=" + encodeURIComponent("" + name) + "&";
        if (pageNumber === null)
            throw new Error("The parameter 'pageNumber' cannot be null.");
        else if (pageNumber !== undefined)
            url_ += "PageNumber=" + encodeURIComponent("" + pageNumber) + "&";
        if (pageSize === null)
            throw new Error("The parameter 'pageSize' cannot be null.");
        else if (pageSize !== undefined)
            url_ += "PageSize=" + encodeURIComponent("" + pageSize) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetExams(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetExams(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<PaginatedListOfExamDto>;
                }
            } else
                return _observableThrow(response_) as any as Observable<PaginatedListOfExamDto>;
        }));
    }

    protected processGetExams(response: HttpResponseBase): Observable<PaginatedListOfExamDto> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = PaginatedListOfExamDto.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    createExam(createExamCommand: CreateExamCommand): Observable<number> {
        let url_ = this.baseUrl + "/api/Exams";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(createExamCommand);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json",
                "Accept": "application/json"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processCreateExam(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processCreateExam(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<number>;
                }
            } else
                return _observableThrow(response_) as any as Observable<number>;
        }));
    }

    protected processCreateExam(response: HttpResponseBase): Observable<number> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
                result200 = resultData200 !== undefined ? resultData200 : <any>null;
    
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    getExamsAll(): Observable<ExamDto[]> {
        let url_ = this.baseUrl + "/api/Exams/List";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetExamsAll(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetExamsAll(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<ExamDto[]>;
                }
            } else
                return _observableThrow(response_) as any as Observable<ExamDto[]>;
        }));
    }

    protected processGetExamsAll(response: HttpResponseBase): Observable<ExamDto[]> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (Array.isArray(resultData200)) {
                result200 = [] as any;
                for (let item of resultData200)
                    result200!.push(ExamDto.fromJS(item));
            }
            else {
                result200 = <any>null;
            }
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    getExam2(id: number): Observable<ExamDto> {
        let url_ = this.baseUrl + "/api/Exams/{id}";
        if (id === undefined || id === null)
            throw new Error("The parameter 'id' must be defined.");
        url_ = url_.replace("{id}", encodeURIComponent("" + id));
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetExam2(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetExam2(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<ExamDto>;
                }
            } else
                return _observableThrow(response_) as any as Observable<ExamDto>;
        }));
    }

    protected processGetExam2(response: HttpResponseBase): Observable<ExamDto> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = ExamDto.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    update(id: number, command: UpdateExamCommand): Observable<ExamDto> {
        let url_ = this.baseUrl + "/api/Exams/{id}";
        if (id === undefined || id === null)
            throw new Error("The parameter 'id' must be defined.");
        url_ = url_.replace("{id}", encodeURIComponent("" + id));
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(command);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json",
                "Accept": "application/json"
            })
        };

        return this.http.request("put", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processUpdate(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processUpdate(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<ExamDto>;
                }
            } else
                return _observableThrow(response_) as any as Observable<ExamDto>;
        }));
    }

    protected processUpdate(response: HttpResponseBase): Observable<ExamDto> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = ExamDto.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    delete(id: number): Observable<number> {
        let url_ = this.baseUrl + "/api/Exams/{id}";
        if (id === undefined || id === null)
            throw new Error("The parameter 'id' must be defined.");
        url_ = url_.replace("{id}", encodeURIComponent("" + id));
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("delete", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processDelete(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processDelete(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<number>;
                }
            } else
                return _observableThrow(response_) as any as Observable<number>;
        }));
    }

    protected processDelete(response: HttpResponseBase): Observable<number> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
                result200 = resultData200 !== undefined ? resultData200 : <any>null;
    
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }
}

export interface IMajorsClient {
    get(name: string | null | undefined, pageNumber: number | undefined, pageSize: number | undefined): Observable<PaginatedListOfMajorDto>;
    createMajor(createMajorCommand: CreateMajorCommand): Observable<number>;
    update(command: UpdateMajorsCommand): Observable<MajorDto>;
    getMajor(id: number): Observable<MajorDto>;
    delete(id: number): Observable<string>;
}

@Injectable({
    providedIn: 'root'
})
export class MajorsClient implements IMajorsClient {
    private http: HttpClient;
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(@Inject(HttpClient) http: HttpClient, @Optional() @Inject(API_BASE_URL) baseUrl?: string) {
        this.http = http;
        this.baseUrl = baseUrl !== undefined && baseUrl !== null ? baseUrl : "";
    }

    get(name: string | null | undefined, pageNumber: number | undefined, pageSize: number | undefined): Observable<PaginatedListOfMajorDto> {
        let url_ = this.baseUrl + "/api/Majors?";
        if (name !== undefined && name !== null)
            url_ += "Name=" + encodeURIComponent("" + name) + "&";
        if (pageNumber === null)
            throw new Error("The parameter 'pageNumber' cannot be null.");
        else if (pageNumber !== undefined)
            url_ += "PageNumber=" + encodeURIComponent("" + pageNumber) + "&";
        if (pageSize === null)
            throw new Error("The parameter 'pageSize' cannot be null.");
        else if (pageSize !== undefined)
            url_ += "PageSize=" + encodeURIComponent("" + pageSize) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGet(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGet(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<PaginatedListOfMajorDto>;
                }
            } else
                return _observableThrow(response_) as any as Observable<PaginatedListOfMajorDto>;
        }));
    }

    protected processGet(response: HttpResponseBase): Observable<PaginatedListOfMajorDto> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = PaginatedListOfMajorDto.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    createMajor(createMajorCommand: CreateMajorCommand): Observable<number> {
        let url_ = this.baseUrl + "/api/Majors";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(createMajorCommand);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json",
                "Accept": "application/json"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processCreateMajor(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processCreateMajor(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<number>;
                }
            } else
                return _observableThrow(response_) as any as Observable<number>;
        }));
    }

    protected processCreateMajor(response: HttpResponseBase): Observable<number> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
                result200 = resultData200 !== undefined ? resultData200 : <any>null;
    
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    update(command: UpdateMajorsCommand): Observable<MajorDto> {
        let url_ = this.baseUrl + "/api/Majors";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(command);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json",
                "Accept": "application/json"
            })
        };

        return this.http.request("put", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processUpdate(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processUpdate(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<MajorDto>;
                }
            } else
                return _observableThrow(response_) as any as Observable<MajorDto>;
        }));
    }

    protected processUpdate(response: HttpResponseBase): Observable<MajorDto> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = MajorDto.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    getMajor(id: number): Observable<MajorDto> {
        let url_ = this.baseUrl + "/api/Majors/{id}";
        if (id === undefined || id === null)
            throw new Error("The parameter 'id' must be defined.");
        url_ = url_.replace("{id}", encodeURIComponent("" + id));
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetMajor(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetMajor(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<MajorDto>;
                }
            } else
                return _observableThrow(response_) as any as Observable<MajorDto>;
        }));
    }

    protected processGetMajor(response: HttpResponseBase): Observable<MajorDto> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = MajorDto.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    delete(id: number): Observable<string> {
        let url_ = this.baseUrl + "/api/Majors/{id}";
        if (id === undefined || id === null)
            throw new Error("The parameter 'id' must be defined.");
        url_ = url_.replace("{id}", encodeURIComponent("" + id));
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("delete", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processDelete(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processDelete(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<string>;
                }
            } else
                return _observableThrow(response_) as any as Observable<string>;
        }));
    }

    protected processDelete(response: HttpResponseBase): Observable<string> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
                result200 = resultData200 !== undefined ? resultData200 : <any>null;
    
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }
}

export interface IMaterialsClient {
    createMaterail(name: string | null | undefined, description: string | null | undefined, courseId: number | undefined, requestId: number | null | undefined, file: FileParameter | null | undefined): Observable<number>;
}

@Injectable({
    providedIn: 'root'
})
export class MaterialsClient implements IMaterialsClient {
    private http: HttpClient;
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(@Inject(HttpClient) http: HttpClient, @Optional() @Inject(API_BASE_URL) baseUrl?: string) {
        this.http = http;
        this.baseUrl = baseUrl !== undefined && baseUrl !== null ? baseUrl : "";
    }

    createMaterail(name: string | null | undefined, description: string | null | undefined, courseId: number | undefined, requestId: number | null | undefined, file: FileParameter | null | undefined): Observable<number> {
        let url_ = this.baseUrl + "/api/Materials";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = new FormData();
        if (name !== null && name !== undefined)
            content_.append("Name", name.toString());
        if (description !== null && description !== undefined)
            content_.append("Description", description.toString());
        if (courseId === null || courseId === undefined)
            throw new Error("The parameter 'courseId' cannot be null.");
        else
            content_.append("CourseId", courseId.toString());
        if (requestId !== null && requestId !== undefined)
            content_.append("RequestId", requestId.toString());
        if (file !== null && file !== undefined)
            content_.append("File", file.data, file.fileName ? file.fileName : "File");

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processCreateMaterail(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processCreateMaterail(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<number>;
                }
            } else
                return _observableThrow(response_) as any as Observable<number>;
        }));
    }

    protected processCreateMaterail(response: HttpResponseBase): Observable<number> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
                result200 = resultData200 !== undefined ? resultData200 : <any>null;
    
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }
}

export interface IRequestsClient {
    create(createRequestCommand: CreateRequestCommand): Observable<number>;
    get(pageNumber: number | undefined, pageSize: number | undefined): Observable<PaginatedListOfRequestDto>;
}

@Injectable({
    providedIn: 'root'
})
export class RequestsClient implements IRequestsClient {
    private http: HttpClient;
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(@Inject(HttpClient) http: HttpClient, @Optional() @Inject(API_BASE_URL) baseUrl?: string) {
        this.http = http;
        this.baseUrl = baseUrl !== undefined && baseUrl !== null ? baseUrl : "";
    }

    create(createRequestCommand: CreateRequestCommand): Observable<number> {
        let url_ = this.baseUrl + "/api/Requests";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(createRequestCommand);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json",
                "Accept": "application/json"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processCreate(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processCreate(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<number>;
                }
            } else
                return _observableThrow(response_) as any as Observable<number>;
        }));
    }

    protected processCreate(response: HttpResponseBase): Observable<number> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
                result200 = resultData200 !== undefined ? resultData200 : <any>null;
    
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    get(pageNumber: number | undefined, pageSize: number | undefined): Observable<PaginatedListOfRequestDto> {
        let url_ = this.baseUrl + "/api/Requests?";
        if (pageNumber === null)
            throw new Error("The parameter 'pageNumber' cannot be null.");
        else if (pageNumber !== undefined)
            url_ += "PageNumber=" + encodeURIComponent("" + pageNumber) + "&";
        if (pageSize === null)
            throw new Error("The parameter 'pageSize' cannot be null.");
        else if (pageSize !== undefined)
            url_ += "PageSize=" + encodeURIComponent("" + pageSize) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGet(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGet(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<PaginatedListOfRequestDto>;
                }
            } else
                return _observableThrow(response_) as any as Observable<PaginatedListOfRequestDto>;
        }));
    }

    protected processGet(response: HttpResponseBase): Observable<PaginatedListOfRequestDto> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = PaginatedListOfRequestDto.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }
}

export interface IStudentClient {
    getStudent(id: string | null): Observable<StudentsDto>;
    create(command: CreateStudentCommand): Observable<number>;
}

@Injectable({
    providedIn: 'root'
})
export class StudentClient implements IStudentClient {
    private http: HttpClient;
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(@Inject(HttpClient) http: HttpClient, @Optional() @Inject(API_BASE_URL) baseUrl?: string) {
        this.http = http;
        this.baseUrl = baseUrl !== undefined && baseUrl !== null ? baseUrl : "";
    }

    getStudent(id: string | null): Observable<StudentsDto> {
        let url_ = this.baseUrl + "/api/Student/{id}";
        if (id === undefined || id === null)
            throw new Error("The parameter 'id' must be defined.");
        url_ = url_.replace("{id}", encodeURIComponent("" + id));
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetStudent(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetStudent(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<StudentsDto>;
                }
            } else
                return _observableThrow(response_) as any as Observable<StudentsDto>;
        }));
    }

    protected processGetStudent(response: HttpResponseBase): Observable<StudentsDto> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = StudentsDto.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    create(command: CreateStudentCommand): Observable<number> {
        let url_ = this.baseUrl + "/api/Student";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(command);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json",
                "Accept": "application/json"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processCreate(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processCreate(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<number>;
                }
            } else
                return _observableThrow(response_) as any as Observable<number>;
        }));
    }

    protected processCreate(response: HttpResponseBase): Observable<number> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
                result200 = resultData200 !== undefined ? resultData200 : <any>null;
    
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }
}

export interface IVolunteersClient {
    getVolunteers(id: number | undefined, pageSize: number | undefined, pageNumber: number | undefined): Observable<PaginatedListOfVolunteerDto>;
}

@Injectable({
    providedIn: 'root'
})
export class VolunteersClient implements IVolunteersClient {
    private http: HttpClient;
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(@Inject(HttpClient) http: HttpClient, @Optional() @Inject(API_BASE_URL) baseUrl?: string) {
        this.http = http;
        this.baseUrl = baseUrl !== undefined && baseUrl !== null ? baseUrl : "";
    }

    getVolunteers(id: number | undefined, pageSize: number | undefined, pageNumber: number | undefined): Observable<PaginatedListOfVolunteerDto> {
        let url_ = this.baseUrl + "/api/Volunteers?";
        if (id === null)
            throw new Error("The parameter 'id' cannot be null.");
        else if (id !== undefined)
            url_ += "Id=" + encodeURIComponent("" + id) + "&";
        if (pageSize === null)
            throw new Error("The parameter 'pageSize' cannot be null.");
        else if (pageSize !== undefined)
            url_ += "PageSize=" + encodeURIComponent("" + pageSize) + "&";
        if (pageNumber === null)
            throw new Error("The parameter 'pageNumber' cannot be null.");
        else if (pageNumber !== undefined)
            url_ += "PageNumber=" + encodeURIComponent("" + pageNumber) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetVolunteers(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetVolunteers(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<PaginatedListOfVolunteerDto>;
                }
            } else
                return _observableThrow(response_) as any as Observable<PaginatedListOfVolunteerDto>;
        }));
    }

    protected processGetVolunteers(response: HttpResponseBase): Observable<PaginatedListOfVolunteerDto> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = PaginatedListOfVolunteerDto.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }
}

export class PaginatedListOfCourseDto implements IPaginatedListOfCourseDto {
    items?: CourseDto[];
    pageNumber?: number;
    totalPages?: number;
    totalCount?: number;
    pageSizee?: number;
    hasPreviousPage?: boolean;
    hasNextPage?: boolean;

    constructor(data?: IPaginatedListOfCourseDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            if (Array.isArray(_data["items"])) {
                this.items = [] as any;
                for (let item of _data["items"])
                    this.items!.push(CourseDto.fromJS(item));
            }
            this.pageNumber = _data["pageNumber"];
            this.totalPages = _data["totalPages"];
            this.totalCount = _data["totalCount"];
            this.pageSizee = _data["pageSizee"];
            this.hasPreviousPage = _data["hasPreviousPage"];
            this.hasNextPage = _data["hasNextPage"];
        }
    }

    static fromJS(data: any): PaginatedListOfCourseDto {
        data = typeof data === 'object' ? data : {};
        let result = new PaginatedListOfCourseDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        if (Array.isArray(this.items)) {
            data["items"] = [];
            for (let item of this.items)
                data["items"].push(item.toJSON());
        }
        data["pageNumber"] = this.pageNumber;
        data["totalPages"] = this.totalPages;
        data["totalCount"] = this.totalCount;
        data["pageSizee"] = this.pageSizee;
        data["hasPreviousPage"] = this.hasPreviousPage;
        data["hasNextPage"] = this.hasNextPage;
        return data;
    }
}

export interface IPaginatedListOfCourseDto {
    items?: CourseDto[];
    pageNumber?: number;
    totalPages?: number;
    totalCount?: number;
    pageSizee?: number;
    hasPreviousPage?: boolean;
    hasNextPage?: boolean;
}

export class CourseDto implements ICourseDto {
    id?: number;
    name?: string;

    constructor(data?: ICourseDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.id = _data["id"];
            this.name = _data["name"];
        }
    }

    static fromJS(data: any): CourseDto {
        data = typeof data === 'object' ? data : {};
        let result = new CourseDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["name"] = this.name;
        return data;
    }
}

export interface ICourseDto {
    id?: number;
    name?: string;
}

export class GetAcademicStaffCoursesQuery implements IGetAcademicStaffCoursesQuery {

    constructor(data?: IGetAcademicStaffCoursesQuery) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
    }

    static fromJS(data: any): GetAcademicStaffCoursesQuery {
        data = typeof data === 'object' ? data : {};
        let result = new GetAcademicStaffCoursesQuery();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        return data;
    }
}

export interface IGetAcademicStaffCoursesQuery {
}

export class CreateCourseCommand implements ICreateCourseCommand {
    name?: string;

    constructor(data?: ICreateCourseCommand) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.name = _data["name"];
        }
    }

    static fromJS(data: any): CreateCourseCommand {
        data = typeof data === 'object' ? data : {};
        let result = new CreateCourseCommand();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["name"] = this.name;
        return data;
    }
}

export interface ICreateCourseCommand {
    name?: string;
}

export class UpdateCourseCommand implements IUpdateCourseCommand {
    id?: number;
    name?: string;

    constructor(data?: IUpdateCourseCommand) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.id = _data["id"];
            this.name = _data["name"];
        }
    }

    static fromJS(data: any): UpdateCourseCommand {
        data = typeof data === 'object' ? data : {};
        let result = new UpdateCourseCommand();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["name"] = this.name;
        return data;
    }
}

export interface IUpdateCourseCommand {
    id?: number;
    name?: string;
}

export class ExamDto implements IExamDto {
    name?: string;
    dueDate?: Date;
    hallNo?: string;
    location?: string | undefined;
    courseId?: number;
    id?: number;

    constructor(data?: IExamDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.name = _data["name"];
            this.dueDate = _data["dueDate"] ? new Date(_data["dueDate"].toString()) : <any>undefined;
            this.hallNo = _data["hallNo"];
            this.location = _data["location"];
            this.courseId = _data["courseId"];
            this.id = _data["id"];
        }
    }

    static fromJS(data: any): ExamDto {
        data = typeof data === 'object' ? data : {};
        let result = new ExamDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["name"] = this.name;
        data["dueDate"] = this.dueDate ? this.dueDate.toISOString() : <any>undefined;
        data["hallNo"] = this.hallNo;
        data["location"] = this.location;
        data["courseId"] = this.courseId;
        data["id"] = this.id;
        return data;
    }
}

export interface IExamDto {
    name?: string;
    dueDate?: Date;
    hallNo?: string;
    location?: string | undefined;
    courseId?: number;
    id?: number;
}

export class PaginatedListOfExamDto implements IPaginatedListOfExamDto {
    items?: ExamDto[];
    pageNumber?: number;
    totalPages?: number;
    totalCount?: number;
    pageSizee?: number;
    hasPreviousPage?: boolean;
    hasNextPage?: boolean;

    constructor(data?: IPaginatedListOfExamDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            if (Array.isArray(_data["items"])) {
                this.items = [] as any;
                for (let item of _data["items"])
                    this.items!.push(ExamDto.fromJS(item));
            }
            this.pageNumber = _data["pageNumber"];
            this.totalPages = _data["totalPages"];
            this.totalCount = _data["totalCount"];
            this.pageSizee = _data["pageSizee"];
            this.hasPreviousPage = _data["hasPreviousPage"];
            this.hasNextPage = _data["hasNextPage"];
        }
    }

    static fromJS(data: any): PaginatedListOfExamDto {
        data = typeof data === 'object' ? data : {};
        let result = new PaginatedListOfExamDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        if (Array.isArray(this.items)) {
            data["items"] = [];
            for (let item of this.items)
                data["items"].push(item.toJSON());
        }
        data["pageNumber"] = this.pageNumber;
        data["totalPages"] = this.totalPages;
        data["totalCount"] = this.totalCount;
        data["pageSizee"] = this.pageSizee;
        data["hasPreviousPage"] = this.hasPreviousPage;
        data["hasNextPage"] = this.hasNextPage;
        return data;
    }
}

export interface IPaginatedListOfExamDto {
    items?: ExamDto[];
    pageNumber?: number;
    totalPages?: number;
    totalCount?: number;
    pageSizee?: number;
    hasPreviousPage?: boolean;
    hasNextPage?: boolean;
}

export class CreateExamCommand implements ICreateExamCommand {
    dueDate?: Date;
    hallNo?: string | undefined;
    location?: string;
    courseId?: number;

    constructor(data?: ICreateExamCommand) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.dueDate = _data["dueDate"] ? new Date(_data["dueDate"].toString()) : <any>undefined;
            this.hallNo = _data["hallNo"];
            this.location = _data["location"];
            this.courseId = _data["courseId"];
        }
    }

    static fromJS(data: any): CreateExamCommand {
        data = typeof data === 'object' ? data : {};
        let result = new CreateExamCommand();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["dueDate"] = this.dueDate ? this.dueDate.toISOString() : <any>undefined;
        data["hallNo"] = this.hallNo;
        data["location"] = this.location;
        data["courseId"] = this.courseId;
        return data;
    }
}

export interface ICreateExamCommand {
    dueDate?: Date;
    hallNo?: string | undefined;
    location?: string;
    courseId?: number;
}

export class UpdateExamCommand implements IUpdateExamCommand {
    id?: number;
    dueDate?: Date;
    hallno?: string;
    location?: string;

    constructor(data?: IUpdateExamCommand) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.id = _data["id"];
            this.dueDate = _data["dueDate"] ? new Date(_data["dueDate"].toString()) : <any>undefined;
            this.hallno = _data["hallno"];
            this.location = _data["location"];
        }
    }

    static fromJS(data: any): UpdateExamCommand {
        data = typeof data === 'object' ? data : {};
        let result = new UpdateExamCommand();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["dueDate"] = this.dueDate ? this.dueDate.toISOString() : <any>undefined;
        data["hallno"] = this.hallno;
        data["location"] = this.location;
        return data;
    }
}

export interface IUpdateExamCommand {
    id?: number;
    dueDate?: Date;
    hallno?: string;
    location?: string;
}

export class PaginatedListOfMajorDto implements IPaginatedListOfMajorDto {
    items?: MajorDto[];
    pageNumber?: number;
    totalPages?: number;
    totalCount?: number;
    pageSizee?: number;
    hasPreviousPage?: boolean;
    hasNextPage?: boolean;

    constructor(data?: IPaginatedListOfMajorDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            if (Array.isArray(_data["items"])) {
                this.items = [] as any;
                for (let item of _data["items"])
                    this.items!.push(MajorDto.fromJS(item));
            }
            this.pageNumber = _data["pageNumber"];
            this.totalPages = _data["totalPages"];
            this.totalCount = _data["totalCount"];
            this.pageSizee = _data["pageSizee"];
            this.hasPreviousPage = _data["hasPreviousPage"];
            this.hasNextPage = _data["hasNextPage"];
        }
    }

    static fromJS(data: any): PaginatedListOfMajorDto {
        data = typeof data === 'object' ? data : {};
        let result = new PaginatedListOfMajorDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        if (Array.isArray(this.items)) {
            data["items"] = [];
            for (let item of this.items)
                data["items"].push(item.toJSON());
        }
        data["pageNumber"] = this.pageNumber;
        data["totalPages"] = this.totalPages;
        data["totalCount"] = this.totalCount;
        data["pageSizee"] = this.pageSizee;
        data["hasPreviousPage"] = this.hasPreviousPage;
        data["hasNextPage"] = this.hasNextPage;
        return data;
    }
}

export interface IPaginatedListOfMajorDto {
    items?: MajorDto[];
    pageNumber?: number;
    totalPages?: number;
    totalCount?: number;
    pageSizee?: number;
    hasPreviousPage?: boolean;
    hasNextPage?: boolean;
}

export class MajorDto implements IMajorDto {
    id?: number;
    name?: string;

    constructor(data?: IMajorDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.id = _data["id"];
            this.name = _data["name"];
        }
    }

    static fromJS(data: any): MajorDto {
        data = typeof data === 'object' ? data : {};
        let result = new MajorDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["name"] = this.name;
        return data;
    }
}

export interface IMajorDto {
    id?: number;
    name?: string;
}

export class CreateMajorCommand implements ICreateMajorCommand {
    name?: string;

    constructor(data?: ICreateMajorCommand) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.name = _data["name"];
        }
    }

    static fromJS(data: any): CreateMajorCommand {
        data = typeof data === 'object' ? data : {};
        let result = new CreateMajorCommand();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["name"] = this.name;
        return data;
    }
}

export interface ICreateMajorCommand {
    name?: string;
}

export class UpdateMajorsCommand implements IUpdateMajorsCommand {
    majorId?: number;
    majorName?: string;

    constructor(data?: IUpdateMajorsCommand) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.majorId = _data["majorId"];
            this.majorName = _data["majorName"];
        }
    }

    static fromJS(data: any): UpdateMajorsCommand {
        data = typeof data === 'object' ? data : {};
        let result = new UpdateMajorsCommand();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["majorId"] = this.majorId;
        data["majorName"] = this.majorName;
        return data;
    }
}

export interface IUpdateMajorsCommand {
    majorId?: number;
    majorName?: string;
}

export class CreateRequestCommand implements ICreateRequestCommand {
    dueDate?: Date;
    examId?: number | undefined;
    requestType?: RequestType | undefined;
    courseId?: number;
    description?: string;

    constructor(data?: ICreateRequestCommand) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.dueDate = _data["dueDate"] ? new Date(_data["dueDate"].toString()) : <any>undefined;
            this.examId = _data["examId"];
            this.requestType = _data["requestType"];
            this.courseId = _data["courseId"];
            this.description = _data["description"];
        }
    }

    static fromJS(data: any): CreateRequestCommand {
        data = typeof data === 'object' ? data : {};
        let result = new CreateRequestCommand();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["dueDate"] = this.dueDate ? this.dueDate.toISOString() : <any>undefined;
        data["examId"] = this.examId;
        data["requestType"] = this.requestType;
        data["courseId"] = this.courseId;
        data["description"] = this.description;
        return data;
    }
}

export interface ICreateRequestCommand {
    dueDate?: Date;
    examId?: number | undefined;
    requestType?: RequestType | undefined;
    courseId?: number;
    description?: string;
}

export enum RequestType {
    Assistance = 1,
    Material = 2,
    Assignment = 4,
}

export class PaginatedListOfRequestDto implements IPaginatedListOfRequestDto {
    items?: RequestDto[];
    pageNumber?: number;
    totalPages?: number;
    totalCount?: number;
    pageSizee?: number;
    hasPreviousPage?: boolean;
    hasNextPage?: boolean;

    constructor(data?: IPaginatedListOfRequestDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            if (Array.isArray(_data["items"])) {
                this.items = [] as any;
                for (let item of _data["items"])
                    this.items!.push(RequestDto.fromJS(item));
            }
            this.pageNumber = _data["pageNumber"];
            this.totalPages = _data["totalPages"];
            this.totalCount = _data["totalCount"];
            this.pageSizee = _data["pageSizee"];
            this.hasPreviousPage = _data["hasPreviousPage"];
            this.hasNextPage = _data["hasNextPage"];
        }
    }

    static fromJS(data: any): PaginatedListOfRequestDto {
        data = typeof data === 'object' ? data : {};
        let result = new PaginatedListOfRequestDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        if (Array.isArray(this.items)) {
            data["items"] = [];
            for (let item of this.items)
                data["items"].push(item.toJSON());
        }
        data["pageNumber"] = this.pageNumber;
        data["totalPages"] = this.totalPages;
        data["totalCount"] = this.totalCount;
        data["pageSizee"] = this.pageSizee;
        data["hasPreviousPage"] = this.hasPreviousPage;
        data["hasNextPage"] = this.hasNextPage;
        return data;
    }
}

export interface IPaginatedListOfRequestDto {
    items?: RequestDto[];
    pageNumber?: number;
    totalPages?: number;
    totalCount?: number;
    pageSizee?: number;
    hasPreviousPage?: boolean;
    hasNextPage?: boolean;
}

export class RequestDto implements IRequestDto {
    courseName?: string;
    id?: number;
    examName?: string | undefined;
    requestType?: string;
    requestStatus?: string;
    dueDate?: Date;
    materialName?: string | undefined;
    volunteerName?: string | undefined;
    description?: string;

    constructor(data?: IRequestDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.courseName = _data["courseName"];
            this.id = _data["id"];
            this.examName = _data["examName"];
            this.requestType = _data["requestType"];
            this.requestStatus = _data["requestStatus"];
            this.dueDate = _data["dueDate"] ? new Date(_data["dueDate"].toString()) : <any>undefined;
            this.materialName = _data["materialName"];
            this.volunteerName = _data["volunteerName"];
            this.description = _data["description"];
        }
    }

    static fromJS(data: any): RequestDto {
        data = typeof data === 'object' ? data : {};
        let result = new RequestDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["courseName"] = this.courseName;
        data["id"] = this.id;
        data["examName"] = this.examName;
        data["requestType"] = this.requestType;
        data["requestStatus"] = this.requestStatus;
        data["dueDate"] = this.dueDate ? this.dueDate.toISOString() : <any>undefined;
        data["materialName"] = this.materialName;
        data["volunteerName"] = this.volunteerName;
        data["description"] = this.description;
        return data;
    }
}

export interface IRequestDto {
    courseName?: string;
    id?: number;
    examName?: string | undefined;
    requestType?: string;
    requestStatus?: string;
    dueDate?: Date;
    materialName?: string | undefined;
    volunteerName?: string | undefined;
    description?: string;
}

export class StudentsDto implements IStudentsDto {
    studentId?: string;
    userId?: string;
    major?: Major;
    user?: ApplicationUser;

    constructor(data?: IStudentsDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.studentId = _data["studentId"];
            this.userId = _data["userId"];
            this.major = _data["major"] ? Major.fromJS(_data["major"]) : <any>undefined;
            this.user = _data["user"] ? ApplicationUser.fromJS(_data["user"]) : <any>undefined;
        }
    }

    static fromJS(data: any): StudentsDto {
        data = typeof data === 'object' ? data : {};
        let result = new StudentsDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["studentId"] = this.studentId;
        data["userId"] = this.userId;
        data["major"] = this.major ? this.major.toJSON() : <any>undefined;
        data["user"] = this.user ? this.user.toJSON() : <any>undefined;
        return data;
    }
}

export interface IStudentsDto {
    studentId?: string;
    userId?: string;
    major?: Major;
    user?: ApplicationUser;
}

export abstract class BaseEntity implements IBaseEntity {
    id?: number;
    domainEvents?: BaseEvent[];

    constructor(data?: IBaseEntity) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.id = _data["id"];
            if (Array.isArray(_data["domainEvents"])) {
                this.domainEvents = [] as any;
                for (let item of _data["domainEvents"])
                    this.domainEvents!.push(BaseEvent.fromJS(item));
            }
        }
    }

    static fromJS(data: any): BaseEntity {
        data = typeof data === 'object' ? data : {};
        throw new Error("The abstract class 'BaseEntity' cannot be instantiated.");
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        if (Array.isArray(this.domainEvents)) {
            data["domainEvents"] = [];
            for (let item of this.domainEvents)
                data["domainEvents"].push(item.toJSON());
        }
        return data;
    }
}

export interface IBaseEntity {
    id?: number;
    domainEvents?: BaseEvent[];
}

export abstract class BaseAuditableEntity extends BaseEntity implements IBaseAuditableEntity {
    created?: Date;
    createdBy?: string | undefined;
    lastModified?: Date | undefined;
    lastModifiedBy?: string | undefined;

    constructor(data?: IBaseAuditableEntity) {
        super(data);
    }

    override init(_data?: any) {
        super.init(_data);
        if (_data) {
            this.created = _data["created"] ? new Date(_data["created"].toString()) : <any>undefined;
            this.createdBy = _data["createdBy"];
            this.lastModified = _data["lastModified"] ? new Date(_data["lastModified"].toString()) : <any>undefined;
            this.lastModifiedBy = _data["lastModifiedBy"];
        }
    }

    static override fromJS(data: any): BaseAuditableEntity {
        data = typeof data === 'object' ? data : {};
        throw new Error("The abstract class 'BaseAuditableEntity' cannot be instantiated.");
    }

    override toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["created"] = this.created ? this.created.toISOString() : <any>undefined;
        data["createdBy"] = this.createdBy;
        data["lastModified"] = this.lastModified ? this.lastModified.toISOString() : <any>undefined;
        data["lastModifiedBy"] = this.lastModifiedBy;
        super.toJSON(data);
        return data;
    }
}

export interface IBaseAuditableEntity extends IBaseEntity {
    created?: Date;
    createdBy?: string | undefined;
    lastModified?: Date | undefined;
    lastModifiedBy?: string | undefined;
}

export class Major extends BaseAuditableEntity implements IMajor {
    name?: string;
    majorGroupId?: number;
    majorGroup?: MajorGroup;
    students?: Student[] | undefined;

    constructor(data?: IMajor) {
        super(data);
    }

    override init(_data?: any) {
        super.init(_data);
        if (_data) {
            this.name = _data["name"];
            this.majorGroupId = _data["majorGroupId"];
            this.majorGroup = _data["majorGroup"] ? MajorGroup.fromJS(_data["majorGroup"]) : <any>undefined;
            if (Array.isArray(_data["students"])) {
                this.students = [] as any;
                for (let item of _data["students"])
                    this.students!.push(Student.fromJS(item));
            }
        }
    }

    static override fromJS(data: any): Major {
        data = typeof data === 'object' ? data : {};
        let result = new Major();
        result.init(data);
        return result;
    }

    override toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["name"] = this.name;
        data["majorGroupId"] = this.majorGroupId;
        data["majorGroup"] = this.majorGroup ? this.majorGroup.toJSON() : <any>undefined;
        if (Array.isArray(this.students)) {
            data["students"] = [];
            for (let item of this.students)
                data["students"].push(item.toJSON());
        }
        super.toJSON(data);
        return data;
    }
}

export interface IMajor extends IBaseAuditableEntity {
    name?: string;
    majorGroupId?: number;
    majorGroup?: MajorGroup;
    students?: Student[] | undefined;
}

export class MajorGroup extends BaseAuditableEntity implements IMajorGroup {
    name?: string;
    majors?: Major[];

    constructor(data?: IMajorGroup) {
        super(data);
    }

    override init(_data?: any) {
        super.init(_data);
        if (_data) {
            this.name = _data["name"];
            if (Array.isArray(_data["majors"])) {
                this.majors = [] as any;
                for (let item of _data["majors"])
                    this.majors!.push(Major.fromJS(item));
            }
        }
    }

    static override fromJS(data: any): MajorGroup {
        data = typeof data === 'object' ? data : {};
        let result = new MajorGroup();
        result.init(data);
        return result;
    }

    override toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["name"] = this.name;
        if (Array.isArray(this.majors)) {
            data["majors"] = [];
            for (let item of this.majors)
                data["majors"].push(item.toJSON());
        }
        super.toJSON(data);
        return data;
    }
}

export interface IMajorGroup extends IBaseAuditableEntity {
    name?: string;
    majors?: Major[];
}

export abstract class BaseEvent implements IBaseEvent {

    constructor(data?: IBaseEvent) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
    }

    static fromJS(data: any): BaseEvent {
        data = typeof data === 'object' ? data : {};
        throw new Error("The abstract class 'BaseEvent' cannot be instantiated.");
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        return data;
    }
}

export interface IBaseEvent {
}

export class Student extends BaseAuditableEntity implements IStudent {
    studentId?: string;
    majorId?: number;
    userId?: string;
    major?: Major;
    user?: ApplicationUser;
    rate?: number | undefined;
    totalRequest?: number | undefined;
    courses?: StudentCourse[] | undefined;

    constructor(data?: IStudent) {
        super(data);
    }

    override init(_data?: any) {
        super.init(_data);
        if (_data) {
            this.studentId = _data["studentId"];
            this.majorId = _data["majorId"];
            this.userId = _data["userId"];
            this.major = _data["major"] ? Major.fromJS(_data["major"]) : <any>undefined;
            this.user = _data["user"] ? ApplicationUser.fromJS(_data["user"]) : <any>undefined;
            this.rate = _data["rate"];
            this.totalRequest = _data["totalRequest"];
            if (Array.isArray(_data["courses"])) {
                this.courses = [] as any;
                for (let item of _data["courses"])
                    this.courses!.push(StudentCourse.fromJS(item));
            }
        }
    }

    static override fromJS(data: any): Student {
        data = typeof data === 'object' ? data : {};
        let result = new Student();
        result.init(data);
        return result;
    }

    override toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["studentId"] = this.studentId;
        data["majorId"] = this.majorId;
        data["userId"] = this.userId;
        data["major"] = this.major ? this.major.toJSON() : <any>undefined;
        data["user"] = this.user ? this.user.toJSON() : <any>undefined;
        data["rate"] = this.rate;
        data["totalRequest"] = this.totalRequest;
        if (Array.isArray(this.courses)) {
            data["courses"] = [];
            for (let item of this.courses)
                data["courses"].push(item.toJSON());
        }
        super.toJSON(data);
        return data;
    }
}

export interface IStudent extends IBaseAuditableEntity {
    studentId?: string;
    majorId?: number;
    userId?: string;
    major?: Major;
    user?: ApplicationUser;
    rate?: number | undefined;
    totalRequest?: number | undefined;
    courses?: StudentCourse[] | undefined;
}

export class IdentityUserOfString implements IIdentityUserOfString {
    id?: string;
    userName?: string | undefined;
    normalizedUserName?: string | undefined;
    email?: string | undefined;
    normalizedEmail?: string | undefined;
    emailConfirmed?: boolean;
    passwordHash?: string | undefined;
    securityStamp?: string | undefined;
    concurrencyStamp?: string | undefined;
    phoneNumber?: string | undefined;
    phoneNumberConfirmed?: boolean;
    twoFactorEnabled?: boolean;
    lockoutEnd?: Date | undefined;
    lockoutEnabled?: boolean;
    accessFailedCount?: number;

    constructor(data?: IIdentityUserOfString) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.id = _data["id"];
            this.userName = _data["userName"];
            this.normalizedUserName = _data["normalizedUserName"];
            this.email = _data["email"];
            this.normalizedEmail = _data["normalizedEmail"];
            this.emailConfirmed = _data["emailConfirmed"];
            this.passwordHash = _data["passwordHash"];
            this.securityStamp = _data["securityStamp"];
            this.concurrencyStamp = _data["concurrencyStamp"];
            this.phoneNumber = _data["phoneNumber"];
            this.phoneNumberConfirmed = _data["phoneNumberConfirmed"];
            this.twoFactorEnabled = _data["twoFactorEnabled"];
            this.lockoutEnd = _data["lockoutEnd"] ? new Date(_data["lockoutEnd"].toString()) : <any>undefined;
            this.lockoutEnabled = _data["lockoutEnabled"];
            this.accessFailedCount = _data["accessFailedCount"];
        }
    }

    static fromJS(data: any): IdentityUserOfString {
        data = typeof data === 'object' ? data : {};
        let result = new IdentityUserOfString();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["userName"] = this.userName;
        data["normalizedUserName"] = this.normalizedUserName;
        data["email"] = this.email;
        data["normalizedEmail"] = this.normalizedEmail;
        data["emailConfirmed"] = this.emailConfirmed;
        data["passwordHash"] = this.passwordHash;
        data["securityStamp"] = this.securityStamp;
        data["concurrencyStamp"] = this.concurrencyStamp;
        data["phoneNumber"] = this.phoneNumber;
        data["phoneNumberConfirmed"] = this.phoneNumberConfirmed;
        data["twoFactorEnabled"] = this.twoFactorEnabled;
        data["lockoutEnd"] = this.lockoutEnd ? this.lockoutEnd.toISOString() : <any>undefined;
        data["lockoutEnabled"] = this.lockoutEnabled;
        data["accessFailedCount"] = this.accessFailedCount;
        return data;
    }
}

export interface IIdentityUserOfString {
    id?: string;
    userName?: string | undefined;
    normalizedUserName?: string | undefined;
    email?: string | undefined;
    normalizedEmail?: string | undefined;
    emailConfirmed?: boolean;
    passwordHash?: string | undefined;
    securityStamp?: string | undefined;
    concurrencyStamp?: string | undefined;
    phoneNumber?: string | undefined;
    phoneNumberConfirmed?: boolean;
    twoFactorEnabled?: boolean;
    lockoutEnd?: Date | undefined;
    lockoutEnabled?: boolean;
    accessFailedCount?: number;
}

export class IdentityUser extends IdentityUserOfString implements IIdentityUser {

    constructor(data?: IIdentityUser) {
        super(data);
    }

    override init(_data?: any) {
        super.init(_data);
    }

    static override fromJS(data: any): IdentityUser {
        data = typeof data === 'object' ? data : {};
        let result = new IdentityUser();
        result.init(data);
        return result;
    }

    override toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        super.toJSON(data);
        return data;
    }
}

export interface IIdentityUser extends IIdentityUserOfString {
}

export class ApplicationUser extends IdentityUser implements IApplicationUser {
    firstName?: string;
    lastName?: string;
    isActive?: boolean;

    constructor(data?: IApplicationUser) {
        super(data);
    }

    override init(_data?: any) {
        super.init(_data);
        if (_data) {
            this.firstName = _data["firstName"];
            this.lastName = _data["lastName"];
            this.isActive = _data["isActive"];
        }
    }

    static override fromJS(data: any): ApplicationUser {
        data = typeof data === 'object' ? data : {};
        let result = new ApplicationUser();
        result.init(data);
        return result;
    }

    override toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["firstName"] = this.firstName;
        data["lastName"] = this.lastName;
        data["isActive"] = this.isActive;
        super.toJSON(data);
        return data;
    }
}

export interface IApplicationUser extends IIdentityUser {
    firstName?: string;
    lastName?: string;
    isActive?: boolean;
}

export class StudentCourse implements IStudentCourse {
    studentId?: number;
    courseId?: number;
    student?: Student;
    course?: Course;

    constructor(data?: IStudentCourse) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.studentId = _data["studentId"];
            this.courseId = _data["courseId"];
            this.student = _data["student"] ? Student.fromJS(_data["student"]) : <any>undefined;
            this.course = _data["course"] ? Course.fromJS(_data["course"]) : <any>undefined;
        }
    }

    static fromJS(data: any): StudentCourse {
        data = typeof data === 'object' ? data : {};
        let result = new StudentCourse();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["studentId"] = this.studentId;
        data["courseId"] = this.courseId;
        data["student"] = this.student ? this.student.toJSON() : <any>undefined;
        data["course"] = this.course ? this.course.toJSON() : <any>undefined;
        return data;
    }
}

export interface IStudentCourse {
    studentId?: number;
    courseId?: number;
    student?: Student;
    course?: Course;
}

export class Course extends BaseAuditableEntity implements ICourse {
    name?: string;
    majorGroupId?: number;
    userId?: string;
    user?: ApplicationUser;
    materials?: Material[] | undefined;
    students?: StudentCourse[] | undefined;
    exams?: Exam[] | undefined;
    majorGroup?: MajorGroup;

    constructor(data?: ICourse) {
        super(data);
    }

    override init(_data?: any) {
        super.init(_data);
        if (_data) {
            this.name = _data["name"];
            this.majorGroupId = _data["majorGroupId"];
            this.userId = _data["userId"];
            this.user = _data["user"] ? ApplicationUser.fromJS(_data["user"]) : <any>undefined;
            if (Array.isArray(_data["materials"])) {
                this.materials = [] as any;
                for (let item of _data["materials"])
                    this.materials!.push(Material.fromJS(item));
            }
            if (Array.isArray(_data["students"])) {
                this.students = [] as any;
                for (let item of _data["students"])
                    this.students!.push(StudentCourse.fromJS(item));
            }
            if (Array.isArray(_data["exams"])) {
                this.exams = [] as any;
                for (let item of _data["exams"])
                    this.exams!.push(Exam.fromJS(item));
            }
            this.majorGroup = _data["majorGroup"] ? MajorGroup.fromJS(_data["majorGroup"]) : <any>undefined;
        }
    }

    static override fromJS(data: any): Course {
        data = typeof data === 'object' ? data : {};
        let result = new Course();
        result.init(data);
        return result;
    }

    override toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["name"] = this.name;
        data["majorGroupId"] = this.majorGroupId;
        data["userId"] = this.userId;
        data["user"] = this.user ? this.user.toJSON() : <any>undefined;
        if (Array.isArray(this.materials)) {
            data["materials"] = [];
            for (let item of this.materials)
                data["materials"].push(item.toJSON());
        }
        if (Array.isArray(this.students)) {
            data["students"] = [];
            for (let item of this.students)
                data["students"].push(item.toJSON());
        }
        if (Array.isArray(this.exams)) {
            data["exams"] = [];
            for (let item of this.exams)
                data["exams"].push(item.toJSON());
        }
        data["majorGroup"] = this.majorGroup ? this.majorGroup.toJSON() : <any>undefined;
        super.toJSON(data);
        return data;
    }
}

export interface ICourse extends IBaseAuditableEntity {
    name?: string;
    majorGroupId?: number;
    userId?: string;
    user?: ApplicationUser;
    materials?: Material[] | undefined;
    students?: StudentCourse[] | undefined;
    exams?: Exam[] | undefined;
    majorGroup?: MajorGroup;
}

export class Material extends BaseAuditableEntity implements IMaterial {
    name?: string;
    description?: string;
    path?: string;
    contentType?: string;
    courseId?: number;
    materialStatus?: MaterialStatus;
    requestId?: number | undefined;
    volunteerStudentId?: number | undefined;
    course?: Course;
    volunteerStudent?: VolunteerStudent | undefined;
    request?: Request | undefined;

    constructor(data?: IMaterial) {
        super(data);
    }

    override init(_data?: any) {
        super.init(_data);
        if (_data) {
            this.name = _data["name"];
            this.description = _data["description"];
            this.path = _data["path"];
            this.contentType = _data["contentType"];
            this.courseId = _data["courseId"];
            this.materialStatus = _data["materialStatus"];
            this.requestId = _data["requestId"];
            this.volunteerStudentId = _data["volunteerStudentId"];
            this.course = _data["course"] ? Course.fromJS(_data["course"]) : <any>undefined;
            this.volunteerStudent = _data["volunteerStudent"] ? VolunteerStudent.fromJS(_data["volunteerStudent"]) : <any>undefined;
            this.request = _data["request"] ? Request.fromJS(_data["request"]) : <any>undefined;
        }
    }

    static override fromJS(data: any): Material {
        data = typeof data === 'object' ? data : {};
        let result = new Material();
        result.init(data);
        return result;
    }

    override toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["name"] = this.name;
        data["description"] = this.description;
        data["path"] = this.path;
        data["contentType"] = this.contentType;
        data["courseId"] = this.courseId;
        data["materialStatus"] = this.materialStatus;
        data["requestId"] = this.requestId;
        data["volunteerStudentId"] = this.volunteerStudentId;
        data["course"] = this.course ? this.course.toJSON() : <any>undefined;
        data["volunteerStudent"] = this.volunteerStudent ? this.volunteerStudent.toJSON() : <any>undefined;
        data["request"] = this.request ? this.request.toJSON() : <any>undefined;
        super.toJSON(data);
        return data;
    }
}

export interface IMaterial extends IBaseAuditableEntity {
    name?: string;
    description?: string;
    path?: string;
    contentType?: string;
    courseId?: number;
    materialStatus?: MaterialStatus;
    requestId?: number | undefined;
    volunteerStudentId?: number | undefined;
    course?: Course;
    volunteerStudent?: VolunteerStudent | undefined;
    request?: Request | undefined;
}

export enum MaterialStatus {
    Pending = 1,
    Rejected = 2,
    Approved = 4,
}

export class VolunteerStudent extends Student implements IVolunteerStudent {
    requests?: RequestVolunteer[] | undefined;

    constructor(data?: IVolunteerStudent) {
        super(data);
    }

    override init(_data?: any) {
        super.init(_data);
        if (_data) {
            if (Array.isArray(_data["requests"])) {
                this.requests = [] as any;
                for (let item of _data["requests"])
                    this.requests!.push(RequestVolunteer.fromJS(item));
            }
        }
    }

    static override fromJS(data: any): VolunteerStudent {
        data = typeof data === 'object' ? data : {};
        let result = new VolunteerStudent();
        result.init(data);
        return result;
    }

    override toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        if (Array.isArray(this.requests)) {
            data["requests"] = [];
            for (let item of this.requests)
                data["requests"].push(item.toJSON());
        }
        super.toJSON(data);
        return data;
    }
}

export interface IVolunteerStudent extends IStudent {
    requests?: RequestVolunteer[] | undefined;
}

export class RequestVolunteer extends BaseAuditableEntity implements IRequestVolunteer {
    requestId?: number;
    volunteerStudentId?: number;
    volunteerStudent?: VolunteerStudent;
    request?: Request;

    constructor(data?: IRequestVolunteer) {
        super(data);
    }

    override init(_data?: any) {
        super.init(_data);
        if (_data) {
            this.requestId = _data["requestId"];
            this.volunteerStudentId = _data["volunteerStudentId"];
            this.volunteerStudent = _data["volunteerStudent"] ? VolunteerStudent.fromJS(_data["volunteerStudent"]) : <any>undefined;
            this.request = _data["request"] ? Request.fromJS(_data["request"]) : <any>undefined;
        }
    }

    static override fromJS(data: any): RequestVolunteer {
        data = typeof data === 'object' ? data : {};
        let result = new RequestVolunteer();
        result.init(data);
        return result;
    }

    override toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["requestId"] = this.requestId;
        data["volunteerStudentId"] = this.volunteerStudentId;
        data["volunteerStudent"] = this.volunteerStudent ? this.volunteerStudent.toJSON() : <any>undefined;
        data["request"] = this.request ? this.request.toJSON() : <any>undefined;
        super.toJSON(data);
        return data;
    }
}

export interface IRequestVolunteer extends IBaseAuditableEntity {
    requestId?: number;
    volunteerStudentId?: number;
    volunteerStudent?: VolunteerStudent;
    request?: Request;
}

export class Request extends BaseAuditableEntity implements IRequest {
    description?: string;
    dueDate?: Date;
    requestType?: RequestType;
    requestStatus?: RequestStatus;
    rate?: number | undefined;
    courseId?: number;
    examId?: number | undefined;
    disabilityStudentId?: number | undefined;
    assignedVolunteerStudentId?: number | undefined;
    assignedVolunteerStudent?: VolunteerStudent | undefined;
    disabilityStudent?: DisabilityStudent;
    course?: Course;
    exam?: Exam | undefined;
    material?: Material[] | undefined;
    feedBacks?: RequestFeedBack[] | undefined;
    volunteers?: RequestVolunteer[] | undefined;

    constructor(data?: IRequest) {
        super(data);
    }

    override init(_data?: any) {
        super.init(_data);
        if (_data) {
            this.description = _data["description"];
            this.dueDate = _data["dueDate"] ? new Date(_data["dueDate"].toString()) : <any>undefined;
            this.requestType = _data["requestType"];
            this.requestStatus = _data["requestStatus"];
            this.rate = _data["rate"];
            this.courseId = _data["courseId"];
            this.examId = _data["examId"];
            this.disabilityStudentId = _data["disabilityStudentId"];
            this.assignedVolunteerStudentId = _data["assignedVolunteerStudentId"];
            this.assignedVolunteerStudent = _data["assignedVolunteerStudent"] ? VolunteerStudent.fromJS(_data["assignedVolunteerStudent"]) : <any>undefined;
            this.disabilityStudent = _data["disabilityStudent"] ? DisabilityStudent.fromJS(_data["disabilityStudent"]) : <any>undefined;
            this.course = _data["course"] ? Course.fromJS(_data["course"]) : <any>undefined;
            this.exam = _data["exam"] ? Exam.fromJS(_data["exam"]) : <any>undefined;
            if (Array.isArray(_data["material"])) {
                this.material = [] as any;
                for (let item of _data["material"])
                    this.material!.push(Material.fromJS(item));
            }
            if (Array.isArray(_data["feedBacks"])) {
                this.feedBacks = [] as any;
                for (let item of _data["feedBacks"])
                    this.feedBacks!.push(RequestFeedBack.fromJS(item));
            }
            if (Array.isArray(_data["volunteers"])) {
                this.volunteers = [] as any;
                for (let item of _data["volunteers"])
                    this.volunteers!.push(RequestVolunteer.fromJS(item));
            }
        }
    }

    static override fromJS(data: any): Request {
        data = typeof data === 'object' ? data : {};
        let result = new Request();
        result.init(data);
        return result;
    }

    override toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["description"] = this.description;
        data["dueDate"] = this.dueDate ? this.dueDate.toISOString() : <any>undefined;
        data["requestType"] = this.requestType;
        data["requestStatus"] = this.requestStatus;
        data["rate"] = this.rate;
        data["courseId"] = this.courseId;
        data["examId"] = this.examId;
        data["disabilityStudentId"] = this.disabilityStudentId;
        data["assignedVolunteerStudentId"] = this.assignedVolunteerStudentId;
        data["assignedVolunteerStudent"] = this.assignedVolunteerStudent ? this.assignedVolunteerStudent.toJSON() : <any>undefined;
        data["disabilityStudent"] = this.disabilityStudent ? this.disabilityStudent.toJSON() : <any>undefined;
        data["course"] = this.course ? this.course.toJSON() : <any>undefined;
        data["exam"] = this.exam ? this.exam.toJSON() : <any>undefined;
        if (Array.isArray(this.material)) {
            data["material"] = [];
            for (let item of this.material)
                data["material"].push(item.toJSON());
        }
        if (Array.isArray(this.feedBacks)) {
            data["feedBacks"] = [];
            for (let item of this.feedBacks)
                data["feedBacks"].push(item.toJSON());
        }
        if (Array.isArray(this.volunteers)) {
            data["volunteers"] = [];
            for (let item of this.volunteers)
                data["volunteers"].push(item.toJSON());
        }
        super.toJSON(data);
        return data;
    }
}

export interface IRequest extends IBaseAuditableEntity {
    description?: string;
    dueDate?: Date;
    requestType?: RequestType;
    requestStatus?: RequestStatus;
    rate?: number | undefined;
    courseId?: number;
    examId?: number | undefined;
    disabilityStudentId?: number | undefined;
    assignedVolunteerStudentId?: number | undefined;
    assignedVolunteerStudent?: VolunteerStudent | undefined;
    disabilityStudent?: DisabilityStudent;
    course?: Course;
    exam?: Exam | undefined;
    material?: Material[] | undefined;
    feedBacks?: RequestFeedBack[] | undefined;
    volunteers?: RequestVolunteer[] | undefined;
}

export enum RequestStatus {
    Created = 1,
    Accepted = 2,
    AcceptedByVolunteer = 4,
    ReAssigning = 8,
    Done = 16,
}

export class DisabilityStudent extends Student implements IDisabilityStudent {
    requests?: Request[] | undefined;

    constructor(data?: IDisabilityStudent) {
        super(data);
    }

    override init(_data?: any) {
        super.init(_data);
        if (_data) {
            if (Array.isArray(_data["requests"])) {
                this.requests = [] as any;
                for (let item of _data["requests"])
                    this.requests!.push(Request.fromJS(item));
            }
        }
    }

    static override fromJS(data: any): DisabilityStudent {
        data = typeof data === 'object' ? data : {};
        let result = new DisabilityStudent();
        result.init(data);
        return result;
    }

    override toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        if (Array.isArray(this.requests)) {
            data["requests"] = [];
            for (let item of this.requests)
                data["requests"].push(item.toJSON());
        }
        super.toJSON(data);
        return data;
    }
}

export interface IDisabilityStudent extends IStudent {
    requests?: Request[] | undefined;
}

export class Exam extends BaseAuditableEntity implements IExam {
    name?: string;
    dueDate?: Date;
    hallNo?: string;
    location?: string | undefined;
    courseId?: number;
    course?: Course;

    constructor(data?: IExam) {
        super(data);
    }

    override init(_data?: any) {
        super.init(_data);
        if (_data) {
            this.name = _data["name"];
            this.dueDate = _data["dueDate"] ? new Date(_data["dueDate"].toString()) : <any>undefined;
            this.hallNo = _data["hallNo"];
            this.location = _data["location"];
            this.courseId = _data["courseId"];
            this.course = _data["course"] ? Course.fromJS(_data["course"]) : <any>undefined;
        }
    }

    static override fromJS(data: any): Exam {
        data = typeof data === 'object' ? data : {};
        let result = new Exam();
        result.init(data);
        return result;
    }

    override toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["name"] = this.name;
        data["dueDate"] = this.dueDate ? this.dueDate.toISOString() : <any>undefined;
        data["hallNo"] = this.hallNo;
        data["location"] = this.location;
        data["courseId"] = this.courseId;
        data["course"] = this.course ? this.course.toJSON() : <any>undefined;
        super.toJSON(data);
        return data;
    }
}

export interface IExam extends IBaseAuditableEntity {
    name?: string;
    dueDate?: Date;
    hallNo?: string;
    location?: string | undefined;
    courseId?: number;
    course?: Course;
}

export class RequestFeedBack extends BaseAuditableEntity implements IRequestFeedBack {
    comment?: string;
    studentId?: number;
    requestId?: number;
    rate?: number;
    student?: Student;
    request?: Request;

    constructor(data?: IRequestFeedBack) {
        super(data);
    }

    override init(_data?: any) {
        super.init(_data);
        if (_data) {
            this.comment = _data["comment"];
            this.studentId = _data["studentId"];
            this.requestId = _data["requestId"];
            this.rate = _data["rate"];
            this.student = _data["student"] ? Student.fromJS(_data["student"]) : <any>undefined;
            this.request = _data["request"] ? Request.fromJS(_data["request"]) : <any>undefined;
        }
    }

    static override fromJS(data: any): RequestFeedBack {
        data = typeof data === 'object' ? data : {};
        let result = new RequestFeedBack();
        result.init(data);
        return result;
    }

    override toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["comment"] = this.comment;
        data["studentId"] = this.studentId;
        data["requestId"] = this.requestId;
        data["rate"] = this.rate;
        data["student"] = this.student ? this.student.toJSON() : <any>undefined;
        data["request"] = this.request ? this.request.toJSON() : <any>undefined;
        super.toJSON(data);
        return data;
    }
}

export interface IRequestFeedBack extends IBaseAuditableEntity {
    comment?: string;
    studentId?: number;
    requestId?: number;
    rate?: number;
    student?: Student;
    request?: Request;
}

export class CreateStudentCommand implements ICreateStudentCommand {
    id?: string;
    major?: string;
    firstName?: string;
    lastName?: string;
    email?: string;
    phoneNumber?: string;
    type?: StudentType;

    constructor(data?: ICreateStudentCommand) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.id = _data["id"];
            this.major = _data["major"];
            this.firstName = _data["firstName"];
            this.lastName = _data["lastName"];
            this.email = _data["email"];
            this.phoneNumber = _data["phoneNumber"];
            this.type = _data["type"];
        }
    }

    static fromJS(data: any): CreateStudentCommand {
        data = typeof data === 'object' ? data : {};
        let result = new CreateStudentCommand();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["major"] = this.major;
        data["firstName"] = this.firstName;
        data["lastName"] = this.lastName;
        data["email"] = this.email;
        data["phoneNumber"] = this.phoneNumber;
        data["type"] = this.type;
        return data;
    }
}

export interface ICreateStudentCommand {
    id?: string;
    major?: string;
    firstName?: string;
    lastName?: string;
    email?: string;
    phoneNumber?: string;
    type?: StudentType;
}

export enum StudentType {
    DisabilityStudent = 0,
    VolunteerStudent = 1,
}

export class PaginatedListOfVolunteerDto implements IPaginatedListOfVolunteerDto {
    items?: VolunteerDto[];
    pageNumber?: number;
    totalPages?: number;
    totalCount?: number;
    pageSizee?: number;
    hasPreviousPage?: boolean;
    hasNextPage?: boolean;

    constructor(data?: IPaginatedListOfVolunteerDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            if (Array.isArray(_data["items"])) {
                this.items = [] as any;
                for (let item of _data["items"])
                    this.items!.push(VolunteerDto.fromJS(item));
            }
            this.pageNumber = _data["pageNumber"];
            this.totalPages = _data["totalPages"];
            this.totalCount = _data["totalCount"];
            this.pageSizee = _data["pageSizee"];
            this.hasPreviousPage = _data["hasPreviousPage"];
            this.hasNextPage = _data["hasNextPage"];
        }
    }

    static fromJS(data: any): PaginatedListOfVolunteerDto {
        data = typeof data === 'object' ? data : {};
        let result = new PaginatedListOfVolunteerDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        if (Array.isArray(this.items)) {
            data["items"] = [];
            for (let item of this.items)
                data["items"].push(item.toJSON());
        }
        data["pageNumber"] = this.pageNumber;
        data["totalPages"] = this.totalPages;
        data["totalCount"] = this.totalCount;
        data["pageSizee"] = this.pageSizee;
        data["hasPreviousPage"] = this.hasPreviousPage;
        data["hasNextPage"] = this.hasNextPage;
        return data;
    }
}

export interface IPaginatedListOfVolunteerDto {
    items?: VolunteerDto[];
    pageNumber?: number;
    totalPages?: number;
    totalCount?: number;
    pageSizee?: number;
    hasPreviousPage?: boolean;
    hasNextPage?: boolean;
}

export class VolunteerDto implements IVolunteerDto {
    id?: number;
    name?: string;
    rating?: number | undefined;
    major?: string;

    constructor(data?: IVolunteerDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.id = _data["id"];
            this.name = _data["name"];
            this.rating = _data["rating"];
            this.major = _data["major"];
        }
    }

    static fromJS(data: any): VolunteerDto {
        data = typeof data === 'object' ? data : {};
        let result = new VolunteerDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["name"] = this.name;
        data["rating"] = this.rating;
        data["major"] = this.major;
        return data;
    }
}

export interface IVolunteerDto {
    id?: number;
    name?: string;
    rating?: number | undefined;
    major?: string;
}

export interface FileParameter {
    data: any;
    fileName: string;
}

export class SwaggerException extends Error {
    override message: string;
    status: number;
    response: string;
    headers: { [key: string]: any; };
    result: any;

    constructor(message: string, status: number, response: string, headers: { [key: string]: any; }, result: any) {
        super();

        this.message = message;
        this.status = status;
        this.response = response;
        this.headers = headers;
        this.result = result;
    }

    protected isSwaggerException = true;

    static isSwaggerException(obj: any): obj is SwaggerException {
        return obj.isSwaggerException === true;
    }
}

function throwException(message: string, status: number, response: string, headers: { [key: string]: any; }, result?: any): Observable<any> {
    if (result !== null && result !== undefined)
        return _observableThrow(result);
    else
        return _observableThrow(new SwaggerException(message, status, response, headers, null));
}

function blobToText(blob: any): Observable<string> {
    return new Observable<string>((observer: any) => {
        if (!blob) {
            observer.next("");
            observer.complete();
        } else {
            let reader = new FileReader();
            reader.onload = event => {
                observer.next((event.target as any).result);
                observer.complete();
            };
            reader.readAsText(blob);
        }
    });
}